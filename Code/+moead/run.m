function A = run(pop, gen, problem_number, scalarization_type)
    %% MOEA/D Main Function
    % Performs multi-objective optimization using the MOEA/D algorithm.
    %
    % Inputs:
    %   - pop: Population size (minimum 20 individuals)
    %   - gen: Number of generations (minimum 5)
    %   - problem_number: Identifier of the benchmark problem to solve.
    %                     The corresponding objective function is predefined.
    %   - scalarization_type: Either 'cheby' (default) or 'linear', to specify the
    %                         scalarizing function used for subproblem decomposition.
    %
    % Description:
    %   This function implements a modified version of the MOEA/D (Multi-Objective
    %   Evolutionary Algorithm based on Decomposition). The population is divided into
    %   subproblems, each guided by a unique weight vector (lambda) and solved via
    %   scalarization of the multi-objective space.
    %
    %   At each generation, offspring are generated by applying Simulated Binary Crossover (SBX)
    %   with 90% probability and Polynomial Mutation with 10% probability (while the original
    %   MOEA/D used mutation only). The neighborhood structure among subproblems is exploited
    %   during mating and replacement phases to promote solution diversity.
    %
    %   The problem-specific parameters such as number of objectives (M), number of decision
    %   variables (V), and their bounds are initialized based on the selected problem_number.

    %% Input validation
    % Assign default values if inputs are missing
    
    if nargin < 3
        problem_number = 1; 
    end
    
    if nargin < 2
        gen = 100;    
    end
    
    if nargin < 1
        pop = 30;
    end
    
    
    % Check that inputs are numeric
    if isnumeric(pop) == 0 || isnumeric(gen) == 0
        error('Both input arguments pop and gen should be integer datatype');
    end
    % Minimum population size has to be 20 individuals
    if pop < 20
        error('Minimum population for running this function is 20');
    end
    if gen < 5
        error('Minimum number of generations is 5');
    end

    % Make sure pop and gen are integers
    pop = round(pop);
    gen = round(gen);
    
    %% Objective Function
    % The objective function description contains information about the
    % objective function. M is the dimension of the objective space, V is the
    % dimension of decision variable space, min_range and max_range are the
    % range for the variables in the decision variable space. User has to
    % define the objective functions using the decision variables. 
    [M, V, min_range, max_range] = utility.get_problem_settings(problem_number);
    
    % Generate the true Pareto front for the selected problem.
    % This is used only for visualization and performance evaluation purposes.
    % The second output (ignored here) contains the reference point used to
    % compute HV.
    [true_pareto, ~] = utility.generate_true_pareto(problem_number, 200);
    
    %% Generation of weight vectors lambda_1, ..., lambda_N
    % For bi-objective problems (M = 2), generate pop evenly spaced weight vectors.
    % Each lambda(i,:) defines a direction in the objective space and corresponds
    % to a subproblem. The weights are linearly distributed along the Pareto front.
    lambda = zeros(pop, M);
    for i = 1 : pop
        lambda(i,1) = (i - 1) / (pop - 1);
        lambda(i,2) = 1 - lambda(i,1);
    end
    
    %% Compute pairwise distances between weight vectors
    % This distance matrix is used to define the neighborhood structure for each subproblem.
    distance_matrix = pdist2(lambda, lambda);  % Euclidean distance
    
    %% Construct the neighborhood B(i) for each subproblem i
    % For each subproblem i, find the T closest weight vectors (including itself)
    % to form its neighborhood B(i,:), which guides mating and replacement.
    T = 10;                 % Neighborhood size (must be â‰¤ pop)
    B = zeros(pop, T);      % B(i,:) contains indices of i's T nearest neighbors
    
    for i = 1:pop
        [~, sorted_idx] = sort(distance_matrix(i,:));  % Sort by increasing distance
        B(i,:) = sorted_idx(1:T);                      % Select T nearest neighbors
    end
    
    %% Initialize the population
    % Population is initialized with random values which are within the
    % specified range. Each chromosome consists of the decision variables and
    % the value of the objective functions, but only the elements
    % of the vector which has the decision variables are operated upon to
    % perform the genetic operations like corssover and mutation.
    chromosome = utility.initialize_variables(pop, M, V, min_range, max_range, problem_number);
    
    %% Initialize the archive
    % Archive is initialized with the initial population
    archive = chromosome;  
    
    %% Initialization of the ideal point z*
    % The ideal point z* is a reference point used in scalarization functions (e.g., Chebyshev).
    % It is initialized as an infinite vector and updated to contain the minimum
    % value found for each objective in the current population.

    z = inf(1, M);  % Initialize ideal point as vector of +Inf
    
    for i = 1:pop
        for j = 1:M
            obj_value = chromosome(i, V + j);  % Extract j-th objective of individual i
            if obj_value < z(j)
                z(j) = obj_value;              % Update ideal point if a better value is found
            end
        end
    end
    
    %% Genetic Operator Parameters
    % These parameters control the intensity of variation introduced during genetic operations.
    % - mum: distribution index for Polynomial Mutation. Higher values lead to smaller perturbations.
    mum = 20;   
    
    %% Start the evolution process
    % The following are performed in each generation
    % * Select the parents which are fit for reproduction
    % * Perfrom crossover and Mutation operator on the selected parents
    % * Perform Selection from the parents and the offsprings
    % * Replace the unfit individuals with the fit individuals to maintain a
    %   constant population size.
  
    upd = utility.textprogressbar(gen);

    for i = 1:gen
        for subproblem = 1:pop
            %% Step 1: Mating selection from the neighborhood
            % A parent is randomly selected from the T closest subproblems (neighbors) of the current one.
            parent_index= B(subproblem, randi(T));
            parent = chromosome(parent_index, :);
    
            %% Step 2: Variation (crossover + mutation)
            % A single offspring is generated using SBX and polynomial mutation.
            % The operator ensures the offspring lies within the allowed variable bounds.
            offspring = moead.genetic_operator(parent, M, V, mum, min_range, max_range, problem_number);
    
            %% Step 3: Update the ideal point z*
            % The ideal point stores the minimum objective values observed so far.
            % It is updated if the offspring improves any of the M objective values.
            for obj = 1:M
                if offspring(V + obj) < z(obj)
                    z(obj) = offspring(V + obj);
                end
            end

            %% Step 3b: Update archive with the new offspring
            archive = [archive; offspring];  % add offspring to archive
            
            
            %% Step 4: Update solutions in the neighborhood
            % For each neighbor of the current subproblem, we check if the new offspring
            % provides a better scalarized fitness (according to the specified method: cheby or linear).
            % If it does, we replace the neighbor's solution with the offspring.
            for neighbor = 1:T
                neighbor_idx = B(subproblem, neighbor);
                
                % Scalar fitness of current neighbor's solution
                fitness_neighbor = moead.scalarization( ...
                    chromosome(neighbor_idx, V+1 : V+M), z, lambda(neighbor_idx, :), scalarization_type);
                
                % Scalar fitness of the new offspring for the same subproblem
                fitness_offspring = moead.scalarization( ...
                    offspring(V+1 : V+M), z, lambda(neighbor_idx, :), scalarization_type);
                
                % Replace neighbor's solution if offspring is better
                if fitness_offspring <= fitness_neighbor
                    chromosome(neighbor_idx, :) = offspring;
                end
            end
        end

        % Periodic archive update with pruning
        N_max = pop; 
        sorted_archive = utility.non_domination_sort_mod(archive, M, V);
        rank1_only = sorted_archive(sorted_archive(:, V + M + 1) == 1, :);
        if size(rank1_only, 1) > N_max
            [~, sort_idx] = sort(rank1_only(:, V + M + 2), 'descend');
            archive = rank1_only(sort_idx(1:N_max), 1:V+M);
        else
            archive = rank1_only(:, 1:V+M);
        end


        upd(i);

        % --- Optional: Visualize intermediate progress (disabled by default) ---
        % The following code allows visualization of the population's evolution
        % during the generational loop. It displays the Pareto front every 100 generations
        % (for M = 2 or M = 3), helping to monitor convergence and diversity.
        %
        % This section is left commented to ensure fair and efficient comparisons
        % across multiple algorithms within the experimental framework.
        % Enabling real-time plotting may significantly slow down performance
        % in large batch experiments or multi-run evaluations.
        %
        %     if ~mod(i,100)
        %         clc
        %         fprintf('%d generations completed\n',i);
        %     end
        %     if M == 2
        %         plot(chromosome(:,V + 1),chromosome(:,V + 2),'*');
        %     elseif M == 3
        %         plot3(chromosome(:,V + 1),chromosome(:,V + 2),chromosome(:,V + 3),'*');
        %     end
        %     fprintf('%d generations completed\n',i);
        %     figure(gcf);
        %     drawnow;
        %     pause(0.01);
    end
    
    
    %% Result
    % Save the result in ASCII text format.
    save solution.txt chromosome -ASCII
    
    %% Visualize
    % The following is used to visualize the result if objective space
    % dimension is visualizable.
    if M == 2
        plot(chromosome(:,V + 1),chromosome(:,V + 2),'b*'); hold on;
        if ~isempty(true_pareto)
            plot(true_pareto(:,1), true_pareto(:,2), 'r-', 'LineWidth', 1.5);
            populationname = sprintf('MOEA/D %s population', scalarization_type);
            legend(populationname, 'True Pareto front', 'Location', 'best');
        end
        hold off;
        filename = sprintf('output/moead_%s.png', scalarization_type);
        saveas(gcf, filename);
    elseif M ==3
        plot3(chromosome(:,V + 1),chromosome(:,V + 2),chromosome(:,V + 3),'*');
    end
        
    %% Extract the first Pareto front (rank = 1) from the final population
    % Each row in 'chromosome' represents a solution, structured as:
    % - Columns 1 to V     : decision variables
    % - Columns V+1 to V+M : objective function values

    % Extract only the objective values from the population
    % f_objs = chromosome(:, V+1:V+M);

    % Identify the non-dominated individuals (first Pareto front)
    % This version of the non-dominated sorting operates only on objective values,
    % and returns the indices of solutions that are not dominated by any others.
    % fronts = moead.non_domination_sort_points(f_objs);

    % The final output A contains only the objective values of the non-dominated
    % individuals (first front), which are used for performance metrics such as
    % GD, IGD, Î”, and HV.
    % A = f_objs(fronts{1}, :);
    
    % Extract only the objective values from the archive
    f_objs = archive(:, V+1:V+M);
    A = f_objs;  % return archive front
end
